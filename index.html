<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MNIST</title>
</head>

<body>
  <div>
    <h1>EMNIST</h1>
  </div>
  <div id="card">
    <canvas id="canvas" width="400" height="400"></canvas>
    <div class="button-container">
      <button onclick="resetCanvas()">Reset</button>
      <button onclick="Recognize()">Recognize</button>
      <button onclick="RecognizeReset()">Recognize and Reset</button>
      <p id="displayText">Draw and clic on Recognize</p>
    </div>
    <canvas id="canvas_test" width="400" height="400"></canvas>
  </div>


  <style>
    body {
      font-family: 'Poppins', sans-serif;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      /* gap: 1rem; */
    }

    #card {
      /* width: 800px;
      height: 800px; */
      /* position: relative;
      margin: auto; */

      /* position: relative; */
      background-color: white;
      box-shadow: 0px 25px 50px rgba(56, 101, 185, 0.678);
      overflow: hidden;
      border-radius: 8px;
      
    }

    #canvas {
      background-color: black;
      margin: auto;
      display: block;
    }

    #canvas_test {
      background-color: black;
      margin: auto;
      display: block;
      width: 400px;
      height: 400px;

      image-rendering: pixelated;
    }


    .button-container {
      margin: 10px;
    }

    button {
      cursor: pointer;
      outline: 0;
      /* display: inline-block; */
      font-weight: 400;
      line-height: 1.5;
      text-align: center;
      background-color: transparent;
      border: 1px solid transparent;
      padding: 6px 12px;
      font-size: 1rem;
      border-radius: .25rem;
      transition: color .15s ease-in-out, background-color .15s ease-in-out, border-color .15s ease-in-out, box-shadow .15s ease-in-out;
      color: #0d6efd;
      border-color: #0d6efd;
    }

    button:hover {
      color: #fff;
      background-color: #0d6efd;
      border-color: #0d6efd;
    }

    #displayText {
      text-align: center;
      font-size: 1rem;
      color: #ffffff;
      border-radius: .25rem;
      /* border-color: #0d6efd; */
      background-color: #0d6efd;
      padding: 6px 12px;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let coord = { x: 0, y: 0 };

    const labels = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    const displayElement = document.getElementById('displayText');


    canvas.addEventListener("mousedown", start);
    document.addEventListener("mouseup", stop);
    // window.addEventListener("resize", resize);

    // resize();

    // function resize() {
    //   ctx.canvas.width = window.innerWidth;
    //   ctx.canvas.height = window.innerHeight;
    // }

    canvas.addEventListener('touchstart', start);
    document.addEventListener('touchend', stop);

    // canvas.addEventListener('touchmove', function (event) {event.preventDefault();});


    function reposition(event) {
      coord.x = (event.touches ? event.touches[0].clientX : event.clientX) - canvas.getBoundingClientRect().left;
      coord.y = (event.touches ? event.touches[0].clientY : event.clientY) - canvas.getBoundingClientRect().top;;
    }
    function start(event) {
      document.addEventListener("mousemove", draw);
      document.addEventListener('touchmove', draw);
      reposition(event);
    }
    function stop() {
      document.removeEventListener("mousemove", draw);
      document.removeEventListener("touchmove", draw);
    }
    function draw(event) {
      ctx.beginPath();
      ctx.lineWidth = 30;
      ctx.lineCap = "round";
      ctx.strokeStyle = "#FFF";
      ctx.moveTo(coord.x, coord.y);
      reposition(event);
      ctx.lineTo(coord.x, coord.y);
      ctx.stroke();
    }

    function resetCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    function Recognize() {
      predict();
    }
    function RecognizeReset() {
      predict();
      resetCanvas();
    }

    async function loadModel() {
      session = await ort.InferenceSession.create('./EMNIST.onnx')
    }
    loadModel()

    async function predict() {
      // const session = await ort.InferenceSession.create('./EMNIST.onnx')

      let tmpCanvas = document.createElement('canvas');
      tmpCanvas.width = canvas.width;
      tmpCanvas.height = canvas.height;
      let tmpCtx = tmpCanvas.getContext('2d');
      tmpCtx.filter = 'blur(6px)';
      tmpCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height);

      let predictCanvas = document.getElementById('canvas_test');
      predictCanvas.width = 28;
      predictCanvas.height = 28;
      let predictCtx = predictCanvas.getContext('2d', { willReadFrequently: true });
      predictCtx.drawImage(tmpCanvas, 0, 0, 28, 28);
      let imgData = predictCtx.getImageData(0, 0, 28, 28).data;

      // console.log("=== imgData", imgData)

      let data = new Float32Array(28 * 28);
      for (let i = 0; i < imgData.length; i++) {
        data[i] = imgData[i * 4 + 3]
      }
      // console.log("=== input", data)

      let transposedData = new Float32Array(28 * 28)
      for (let y = 0; y < 28; y++) {
        for (let x = 0; x < 28; x++) {
          transposedData[x * 28 + y] = data[y * 28 + x]
        }
      }

      const input = new ort.Tensor('float32', transposedData, [1, 1, 28, 28])
      const result = await session.run({ 'input': input })
      const logits = result.output.data
      const probas = softmax(logits)
      // console.log("=== Result", probas)
      let maxIndex = indexOfMax(probas)
      let label = labels[maxIndex]
      console.log("=== label", label)
      displayElement.textContent = "the model predicted : " + label + " with probability : " + probas[maxIndex].toFixed(2);
    }

    const getImgData = () => {
      const data = []
      for (let i = 0; i < 1 * 1 * 28 * 28; ++i) {
        data.push(0)
      }
      return data
    }

    const softmax = (data) => {
      const exps = data.map((value) => Math.exp(value))
      const sumExps = exps.reduce((acc, val) => acc + val)
      return exps.map((exp) => exp / sumExps)
    }

    function indexOfMax(arr) {
      if (arr.length === 0) {
        return -1;
      }

      var max = arr[0];
      var maxIndex = 0;

      for (var i = 1; i < arr.length; i++) {
        if (arr[i] > max) {
          maxIndex = i;
          max = arr[i];
        }
      }

      return maxIndex;
    }

    // const main = async () => {
    //   session = await ort.InferenceSession.create('./EMNIST.onnx')
    //   const data = Float32Array.from(getImgData()).map((pixel) => (pixel - 0.1307) / 0.3081)
    //   const input = new ort.Tensor('float32', data, [1, 1, 28, 28])
    //   const result = await session.run({ 'input': input })
    //   const logits = result.output.data
    //   const probas = softmax(logits)
    //   console.log("=== Result", probas)
    // }
    // main()
  </script>
</body>

</html>